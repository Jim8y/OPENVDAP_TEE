#include <stdio.h>
#include <map>
#include <random>
#include <string>
#include "openvdap_t.h" // Headers for trusted part (autogenerated by edger8r)
#include "dispatcher.h"
#include "openvdap_aes.h"
#include "openvdap_ecdsa.h"
#include "openvdap_ecp.h"
#include <mbedtls/platform.h>
#include <mbedtls/sha256.h>
#include "message.h"
#include "common/shared.h"
#include "sqlite3.h"
#include <iostream>

//#define LEN_128
//#define LEN_256
#define LEN 1024
#define _TEST_ECDSA_
//#define _TEST_AES_

static ecall_dispatcher dispatcher;

static const char* dbname = ":memory:";
static sqlite3* db;  // Database connection object

/**
 * Unseal data in enclave
 * @param sealed_data
 * @param sealed_data_size
 * @param data unsealed data
 * @param data_size
 * @return int result
 */
int ecall_openvdap_unseal_data(
        sealed_data_t* sealed_data,
        size_t sealed_data_size,
        unsigned char** data,
        size_t* data_size)
{
    printf("Enclave: unseal_data\n");
    return dispatcher.unseal_data(
            sealed_data, sealed_data_size, data, data_size);
}

/**
 * Initialize the TEE account, if already generated,
 * will load from the enclave, otherwise create a new one
 * @param seed seed to create a new TEE account not necessary
 * @param pubkey TEE account pubkey
 * @param addr TEE account Addr
 * @return int
 */
int ecall_openvdap_init_tee(
        const char* seed,
        const char* pubkey,
        const char* addr)
{
    unsigned char opt_mgs[128] = "hello world";
    size_t opt_msg_len = strlen((char*)opt_mgs);
    unsigned char* data = (unsigned char*)seed;
    size_t data_size = strlen((char*)data) + 1;
    sealed_data_t* sealed_data = NULL;

    initial_aes();

    size_t sealed_data_size = 0;
    int result = dispatcher.seal_data(
            POLICY_UNIQUE,
            opt_mgs,
            opt_msg_len,
            data,
            data_size,
            &sealed_data,
            &sealed_data_size);

    if (result != OE_OK)
    {
        cout << "Host: seal_data failed with " << result << endl;
    }
    initial_aes();
    return -1;
}



/**
 * Load contract into Contract engine
 * @param contract_definition Contract detail (script and function hash)
 * @param address
 * @param addr_size
 */
void ecall_openvdap_main(
        const char* contract_definition,
        char* address,
        size_t addr_size)
{

}

/**
 * SQLite callback function for printing results
 */
static int callback(void* NotUsed, int argc, char** argv, char** azColName)
{
    int i;
    std::cout<<"\n==============* RESULT *===================="<<std::endl;
    for (i = 0; i < argc; i++)
    {
        std::string azColName_str = azColName[i];
        std::string argv_str = (argv[i] ? argv[i] : "NULL");
        std::cout<<(azColName_str + " = " + argv_str).c_str()<<std::endl;
    }
    std::cout<<"============================================="<<std::endl;
    std::cout<<"\n"<<std::endl;
    return 0;
}

/**
 * Open the keynote
 */
void ecall_openvdap_open_keynote()
{
    int rc;                         // For return status of SQLite
    TRACE_ENCLAVE("Open Database");
    rc = sqlite3_open(":memory:", &db); // Opening database
    if (rc)
    {
        std::cout<<"SQLite error - can't open database connection: "<<std::endl;
        std::cout<<sqlite3_errmsg(db)<<std::endl;
        return;
    }
    std::cout<<"Enclave: Created database connection to "<<std::endl;

    const char* create_table = "CREATE TABLE openvdap (\n"
                               "        entity_id INTEGER PRIMARY KEY AUTOINCREMENT,\n"
                               "        msg NVARCHAR,\n"
                               "        owner NVARCHAR\n"
                               "    );";
    TRACE_ENCLAVE("Create Table 'openvdap'");
    ecall_openvdap_execute_cmd(create_table);
    ecall_openvdap_execute_cmd("INSERT INTO openvdap (msg, owner)\n"
                               "VALUES('add', '1');");
    ecall_openvdap_execute_cmd("SELECT * FROM openvdap;");
}

void ecall_openvdap_execute_cmd(const char* sql)
{
    int rc;
    char* zErrMsg = 0;
    TRACE_ENCLAVE("%s",sql);

    rc = sqlite3_exec(db, sql, callback, 0, &zErrMsg);
    if (rc)
    {
        TRACE_ENCLAVE("ERROR Code = %d Msg = %s",rc, zErrMsg);
        std::cout<<"SQLite error: "<<std::endl;
        std::cout<<sqlite3_errmsg(db)<<std::endl;
        return;
    }
}

void ecall_openvdap_close_keynote()
{
    sqlite3_close(db);
    std::cout<<"Enclave: Closed database connection"<<std::endl;
}

// Execute ADD command statement inside enclave
void ecall_openvdap_execute_cmd_add(
        const char* msg,
        const char* sig,
        const char* owner,
        const char* id)
{
    TRACE_ENCLAVE("Entering ecall_openvdap_execute_cmd_add");

    std::string add = "INSERT INTO openvdap (msg, owner)\n"
                      "VALUES('" +
            std::string(msg) + "', '" + owner + "');";
    ecall_openvdap_execute_cmd(add.c_str());
}

// Execute UPDATE command statement inside enclave
void ecall_openvdap_execute_cmd_update(const char* id, const char* msg, const char* sig)
{
    std::cout<<"Enclave: Created database connection to "<<std::endl;
    std::cout<<dbname<<std::endl;

    string update = "UPDATE openvdap\n"
                         "SET msg = " + std::string(msg) +
                         ", WHERE\n"
                         "    id= " +
                         id + " ";
    ecall_openvdap_execute_cmd(update.c_str());
}

// Execute command DELETE statement inside enclave
void ecall_openvdap_execute_cmd_delete(const char* id, const char* sig)
{
    string del = "DELETE FROM openvdap WHERE entity_id = '" + std::string(id) + "';";
    ecall_openvdap_execute_cmd(del.c_str());
}

// Execute QUERY command statement inside enclave
void ecall_openvdap_execute_cmd_query(const char* id, const char* sig, const char* res)
{
    std::cout<<"Enclave: Created database connection to "<<std::endl;
    std::cout<<dbname<<std::endl;

    string query =
            "SELECT * FROM openvdap WHERE entity_id = '" + std::string(id) + "';";
    ecall_openvdap_execute_cmd(query.c_str());
}

// Execute ADD command statement inside enclave
void ecall_openvdap_execute_cmd_enc(
        const char* id,
        const char* msg,
        const char* sig,
        const char* res)
{
    string select =
            "SELECT msg FROM openvdap WHERE entity_id = '" + std::string(id) + "';";
    ecall_openvdap_execute_cmd(select.c_str());

    char key[LEN] = {'\0'};
    char pubkey[LEN] = {'\0'};
    ////    print_hex("Method 1", output1, sizeof output1);
    aes_encrypt((unsigned char*)msg, LEN / 16, (unsigned char*)res);
    aes_finish();
    aes_test();
}

// Execute UPDATE command statement inside enclave
void ecall_openvdap_execute_cmd_dec(const char* id, const char* sig, const char* res)
{
    string select =
            "SELECT msg FROM openvdap WHERE entity_id = '" + std::string(id) + "';";
    ecall_openvdap_execute_cmd(select.c_str());

    char key[LEN] = {'\0'};
    char pubkey[LEN] = {'\0'};
    ////    print_hex("Method 1", output1, sizeof output1);
    aes_decrypt((char*)id, LEN / 16, (unsigned char*)res);
    aes_finish();
    aes_test();
}

// Execute command DELETE statement inside enclave
void ecall_openvdap_execute_cmd_sign(const char* id, const char* msg, const char* res)
{
    string select =
            "SELECT msg FROM openvdap WHERE entity_id = '" + std::string(id) + "';";
    ecall_openvdap_execute_cmd(select.c_str());

    unsigned char output1[32];

    mbedtls_sha256_ret((const unsigned char*)msg, LEN, output1, 0);
    ecdsa_sign(output1);
}

// Execute QUERY command statement inside enclave
void ecall_openvdap_execute_cmd_verify(const char* id, const char* sig, const char* res)
{
    string select =
            "SELECT msg FROM openvdap WHERE entity_id = '" + std::string(id) + "';";

    ecall_openvdap_execute_cmd(select.c_str());

    unsigned char output1[32];
    mbedtls_sha256_ret((const unsigned char*)id, LEN, output1, 0);
    ecdsa_verify((const uint8_t *)output1, (const uint8_t *)sig, 32);
}

int initialize_encryptor(
        bool encrypt,
        const char* password,
        size_t password_len,
        encryption_header_t* header)
{
    return dispatcher.initialize(encrypt, password, password_len, header);
}

int encrypt_block(
        bool encrypt,
        unsigned char* input_buf,
        unsigned char* output_buf,
        size_t size)
{
    return dispatcher.encrypt_block(encrypt, input_buf, output_buf, size);
}

void close_encryptor()
{
    return dispatcher.close();
}